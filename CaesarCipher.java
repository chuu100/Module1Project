import org.w3c.dom.ls.LSOutput;import java.io.*;import java.util.*;public class CaesarCipher {    private static final List<Character> ALPHABET = Arrays.asList('а', 'б', 'в', 'г', 'д', 'е', 'ё', 'ж',            'з', 'и', 'й', 'к', 'л', 'м', 'н', 'о', 'п', 'р', 'с', 'т', 'у', 'ф',            'х', 'ц', 'ч', 'ш', 'щ', 'ъ', 'ы', 'ь', 'э', 'ю', 'я', 'А', 'Б', 'В',            'Г', 'Д', 'Е', 'Ё', 'Ж', 'З', 'И', 'Й', 'К', 'Л', 'М', 'Н', 'О', 'П',            'Р', 'С', 'Т', 'У', 'Ф', 'Х', 'Ц', 'Ч', 'Ш', 'Щ', 'Ъ', 'Ы', 'Ь', 'Э',            'Ю', 'Я', '.', ',', '"', '«', '»', '(', ')', ':', '!', '?', ' ', '-', '\'');    public static int key;    public static boolean niceKey = false;    public static void main(String[] args) {        String mod = "";        while (!mod.equals("exit")) {            System.out.println("Выберите режим работы программы:");            System.out.println("1 - зашифровать файл с помощью ключа");            System.out.println("2 - расшифровать файл с помощью ключа");            System.out.println("3 - расшифровать файл методом BruteForce");            System.out.println("4 - расшифровать файл с помощью статестического анализа");            System.out.println("Для завершения работы введите \"exit\"");            System.out.println();            Scanner console = new Scanner(System.in);            mod = console.nextLine();            try {                if (Integer.parseInt(mod) == 1) {                    System.out.println("Введите путь к файлу, который необходимо зашифровать");                    String src = console.nextLine();                    //Для удобства тестирования рекомендую задать путь сразу                    //String src = "/Users/a.mokropolov/Coding/Module1project/sourceFile.txt";                    System.out.println();                    System.out.println("Введите ключ шифрования для алгоритма Цезаря");                    key = Integer.parseInt(console.nextLine());                    System.out.println();                    System.out.println("Введите путь для зашифрованного файла");                    String encryptedFile = console.nextLine();                    //Для удобства тестирования рекомендую задать путь сразу                    //String encryptedFile = "/Users/a.mokropolov/Coding/Module1project/encryptedFile.txt";                    System.out.println();                    System.out.println("Исходный текст");                    System.out.println();                    printFile(src);                    System.out.println();                    System.out.println("Шифрование началось..");                    encryptFile(src, key, encryptedFile);                    System.out.println("Зашифрованный файл:");                    printFile(encryptedFile);                }                else if (Integer.parseInt(mod) == 2) {                    System.out.println("Введите путь к зашифрованному файлу");                    String encryptedFile = console.nextLine();                    //Для удобства тестирования рекомендую задать путь сразу                    //String encryptedFile = "/Users/a.mokropolov/Coding/Module1project/encryptedFile.txt";                    System.out.println("Введите путь к файлу, в который нужно записать расшифрованный файл:");                    String decryptedFile = console.nextLine();                    //Для удобства тестирования рекомендую задать путь сразу                    //String decryptedFile = "/Users/a.mokropolov/Coding/Module1project/decryptedFile.txt";                    System.out.println("Введите ключ для расшифровки файла:");                    key = Integer.parseInt(console.nextLine());                    System.out.println("Расшифровка файла началась..");                    decryptFile(encryptedFile, key, decryptedFile);                    System.out.println("Расшифрованный файл:");                    printFile(decryptedFile);                }                else if (Integer.parseInt(mod) == 3) {                    System.out.println("Введите путь к зашифрованному файлу");                    String encryptedFile = console.nextLine();                    //Для удобства тестирования рекомендую задать путь сразу                    //String encryptedFile = "/Users/a.mokropolov/Coding/Module1project/encryptedFile.txt";                    System.out.println("Введите путь к файлу, в который нужно записать расшифрованный файл:");                    String bruteForceDecryptedFile = console.nextLine();                    //Для удобства тестирования рекомендую задать путь сразу                    //String bruteForceDecryptedFile = "/Users/a.mokropolov/Coding/Module1project/decryptedFileBruteForce.txt";                    System.out.println("Расшифровка файла началась..");                    bruteForce(encryptedFile, bruteForceDecryptedFile);                }                else if (Integer.parseInt(mod) == 4) {                    System.out.println("Введите путь к зашифрованному файлу");                    String encryptedFile = console.nextLine();                    //Для удобства тестирования рекомендую задать путь сразу                    // String encryptedFile = "/Users/a.mokropolov/Coding/Module1project/encryptedFile.txt";                    System.out.println("Введите путь к файлу - примеру того же автора");                    String exampleFile = console.nextLine();                    //Для удобства тестирования рекомендую задать путь сразу                    //String exampleFile = "/Users/a.mokropolov/Coding/Module1project/example.txt";                    System.out.println("Введите путь к файлу, в который нужно записать расшифрованный файл:");                    String statisticDecryptedFile = console.nextLine();                    //Для удобства тестирования рекомендую задать путь сразу                    //String statisticDecryptedFile = "/Users/a.mokropolov/Coding/Module1project/decryptedFileStatistic.txt";                    System.out.println("Расшифровка файла началась..");                    statisticsMethod(encryptedFile, exampleFile, statisticDecryptedFile);                    System.out.println("Расшифрованный файл:");                }                else {                    System.out.println("Некорректный ввод");                }            } catch (NumberFormatException ex) {                if (mod.equals("exit")) {                    break;                } else {                    System.out.println("Некорректный ввод");                }            }        }    }    public static void printFile(String src) {        try (BufferedReader bufferedReader = new BufferedReader(new FileReader(src))) {            String line;            while ((line = bufferedReader.readLine()) != null) {                System.out.println(line);            }        } catch (IOException ex) {            System.out.println(ex.getMessage());        }    }    //Метод зашифровки файла с использованием заданного ключа    public static void encryptFile(String src, int key, String dst) {        try (BufferedReader bufferedReader = new BufferedReader(new FileReader(src));             BufferedWriter bufferedWriter = new BufferedWriter(new FileWriter(dst))) {            String line;            while ((line = bufferedReader.readLine()) != null) {                char[] array = line.toCharArray();                char[] encryptArray = new char[array.length + 1];                for (int i = 0; i < array.length; i++) {                    encryptArray[i] = encryptCharacter(array[i], key);                }                encryptArray[encryptArray.length - 1] = '\n';                bufferedWriter.write(encryptArray);            }        } catch (IOException e) {            System.out.println(e.getMessage());        }    }    //Метод для посимвольного сдвига по алфавиту    public static char encryptCharacter(char ch, int key) {        int indexOfAlphabet = ALPHABET.indexOf(ch);        if (indexOfAlphabet != -1) {            return ALPHABET.get((indexOfAlphabet + key) % ALPHABET.size());        } else return ch;    }    //Метод для посильного декодирования(сдвиг по алфавиту в обратную сторону)    public static char decryptCharacter(char ch, int key) {        int indexOfAlphabet = ALPHABET.indexOf(ch);        if (indexOfAlphabet != -1) {            int encryptIndex = indexOfAlphabet - key;            if (encryptIndex < 0) {                int value = encryptIndex;                encryptIndex = (ALPHABET.size() + value) % ALPHABET.size();            }            return ALPHABET.get(encryptIndex);        } else return ch;    }    //Метод дешифрования файла с использованием заданного ключа (Пункт - 2 в меню)    public static void decryptFile(String srcEncryptedFile, int keyValue, String dstDecryptedFile) {        try (BufferedReader bufferedReader = new BufferedReader(new FileReader(srcEncryptedFile));             BufferedWriter bufferedWriter = new BufferedWriter(new FileWriter(dstDecryptedFile))) {            String line;            while ((line = bufferedReader.readLine()) != null) {                char[] array = line.toCharArray();                char[] decryptedArray = new char[array.length + 1];                for (int i = 0; i < array.length; i++) {                    decryptedArray[i] = decryptCharacter(array[i], keyValue);                }                decryptedArray[decryptedArray.length - 1] = '\n';                bufferedWriter.write(decryptedArray);            }        } catch (IOException e) {            System.out.println(e.getMessage());        }    }    //Метод чтения строк из файла в ArrayList для дальнейшей работы со списком    public static ArrayList<String> readFileFromFile(String fileName) {        ArrayList<String> lines = new ArrayList<>();        try (FileReader fileReader = new FileReader(fileName);             BufferedReader bufferedReader = new BufferedReader(fileReader)) {            String str;            while ((str = bufferedReader.readLine()) != null) {                lines.add(str);            }        } catch (IOException ex) {            System.out.println(ex.getMessage());        }        return lines;    }    //Метод расшифровки файла с помощью bruteForce'а.    public static void bruteForce(String encryptedFileName, String decryptedFileName) {        int keyValue = 1;        niceKey = false;        while (!niceKey) {            int correctlinesCount = 0;            if (keyValue > ALPHABET.size()) {                System.out.println("badCode");                break;            }            decryptFile(encryptedFileName, keyValue, decryptedFileName);            ArrayList<String> lines = readFileFromFile(decryptedFileName);            String str;            for (String s : lines) {                char[] lineElement;                lineElement = s.toCharArray();                int spaceCount = 0;                int dotCount = 0;                int commaCount = 0;                int questionMarkCount = 0;                int exclamationPointCount = 0;                //Делаем проверку на наличие пробела после знаков препинания, при условии, что пробел в данном случае - не последний символ строки                for (int i = 0; i < lineElement.length - 2; i++) {                    if ((lineElement[i] == '.') && (lineElement[i + 1] == ' ') && (i + 1 != lineElement.length - 1))                        dotCount++;                    else if ((lineElement[i] == ',') && (lineElement[i + 1] == ' ') && (i + 1 != lineElement.length - 1))                        commaCount++;                    else if ((lineElement[i] == '?') && (lineElement[i + 1] == ' ') && (i + 1 != lineElement.length - 1))                        questionMarkCount++;                    else if ((lineElement[i] == '!') && (lineElement[i + 1] == ' ') && (i + 1 != lineElement.length - 1))                        exclamationPointCount++;                }                if (s.length() > 15 && ((dotCount > 0) || commaCount > 0 || questionMarkCount > 0 || exclamationPointCount > 0)) {                    correctlinesCount++;                }                if (correctlinesCount > lines.size() / 3) {                    System.out.println(keyValue);                    niceKey = true;                    break;                }            }            if (!niceKey) {                keyValue++;            } else {                System.out.println("Расшифрованный файл");                printFile(decryptedFileName);                System.out.println("Ключ - " + keyValue);            }        }    }    public static void statisticsMethod(String encryptedFileName, String primerFileName, String decryptedFileName) {        //Алфавит без знаков пунктуации        List<Character> alphabetForAnalise = Arrays.asList('а', 'б', 'в', 'г', 'д', 'е', 'ё', 'ж',                'з', 'и', 'й', 'к', 'л', 'м', 'н', 'о', 'п', 'р', 'с', 'т', 'у', 'ф',                'х', 'ц', 'ч', 'ш', 'щ', 'ъ', 'ы', 'ь', 'э', 'ю', 'я', 'А', 'Б', 'В',                'Г', 'Д', 'Е', 'Ё', 'Ж', 'З', 'И', 'Й', 'К', 'Л', 'М', 'Н', 'О', 'П',                'Р', 'С', 'Т', 'У', 'Ф', 'Х', 'Ц', 'Ч', 'Ш', 'Щ', 'Ъ', 'Ы', 'Ь', 'Э',                'Ю', 'Я');        int keyValue = 1;        niceKey = false;        //Счетчик количества вхождений символов алфавита для текста-примера        int[] countArray = new int[ALPHABET.size()];        //Счетчик количества вхождений символов алфавита для очередного расшифрованного текста        int[] countArrayEncrypted = new int[ALPHABET.size()];        //Массив символов для каждой строки текста-примера        char[] lineCharacter;        //Массив символов для каждой строки очередного расшифрованного текста        char[] lineCharacterEncrypted;        //Массив статистических показателей вхождения каждого символа алфавита для текст-примера        float[] statForExampleFile = new float[ALPHABET.size()];        //Массив статистических показателей вхождения каждого символа алфавита для очередного расшифрованного текста        float[] statForEncryptedFile = new float[ALPHABET.size()];        //Количество вхождений в текст символов, входящих в наш алфавит. Для подсчета процентного соотношения числа вхождений        long countOfCharacterInPrimerText = 0;        //массив строк файла        ArrayList<String> lines = readFileFromFile(primerFileName);        for (String str : lines) {            lineCharacter = str.toCharArray();            //Переводим строку в массив символов и считаем сколько раз символ алфавита вошел в текст(индекс массива соответсвует индексу элемента в алфавите)            for (char c : lineCharacter) {                if (alphabetForAnalise.contains(c)) {                    countArray[alphabetForAnalise.lastIndexOf(c)]++;                    //Плюсуем общее количество символов из нашего алфавита в тексте                    countOfCharacterInPrimerText++;                }            }        }        for (int i = 0; i < countArray.length; i++) {            //Считаем количество вхождений элементов алфавита в текст в процентном соотношении            statForExampleFile[i] = (float) countArray[i] * 100 / countOfCharacterInPrimerText;        }//Пока не подобрали ключ - повторяем подбор ключа и подсчет статистики вхождений        while (!niceKey) {            //Перед каждой итерацией обнуляем массив с количеством вхождений в текст символов нашего алфавита            System.out.println(keyValue);            Arrays.fill(countArrayEncrypted, 0);            long countOfCharacterInEncryptText = 0;            //расшифровываем текст с очередным ключем            decryptFile(encryptedFileName, keyValue, decryptedFileName);            //заполняем массив строк из файла            ArrayList<String> linesInEncryptedFile = readFileFromFile(decryptedFileName);            for (String s : linesInEncryptedFile) {                //считаем  вхождения элементов алфавита в текст                lineCharacterEncrypted = s.toCharArray();                for (char c : lineCharacterEncrypted) {                    if (alphabetForAnalise.contains(c)) {                        countArrayEncrypted[alphabetForAnalise.lastIndexOf(c)]++;                        countOfCharacterInEncryptText++;                    }                }            }            //переводим в проценты            for (int i = 0; i < countArrayEncrypted.length; i++) {                statForEncryptedFile[i] = (float) (countArrayEncrypted[i]) * 100 / countOfCharacterInEncryptText;            }            //Если индекс элемента с максимальным числом вхождений в текст у обоих текстов совпадает, то расшифровка произошла правильно            if (maxElementIndexEquals(statForExampleFile, statForEncryptedFile)) {                niceKey = true;                printFile(decryptedFileName);                System.out.println("Ключ - " + keyValue);            } else keyValue++;//иначе - следующий ключ        }    }    //метод сравнения количества вхождений у текста-примера и расшифрованного текста    public static boolean maxElementIndexEquals(float[] array1, float[] array2) {        int maxValueIndex1 = 0;        int maxValueIndex2 = 0;        float maxValue1 = 0;        float maxValue2 = 0;        for (int i = 0; i < array1.length; i++) {            if (array1[i] > maxValue1) {                maxValue1 = array1[i];                maxValueIndex1 = i;            }        }        for (int i = 0; i < array2.length; i++) {            if (array2[i] > maxValue2) {                maxValue2 = array2[i];                maxValueIndex2 = i;            }        }        return maxValueIndex1 == maxValueIndex2;    }}